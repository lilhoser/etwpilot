/* 
Licensed to the Apache Software Foundation (ASF) under one
or more contributor license agreements.  See the NOTICE file
distributed with this work for additional information
regarding copyright ownership.  The ASF licenses this file
to you under the Apache License, Version 2.0 (the
"License"); you may not use this file except in compliance
with the License.  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing,
software distributed under the License is distributed on an
"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, either express or implied.  See the License for the
specific language governing permissions and limitations
under the License.
*/
using Microsoft.SemanticKernel.ChatCompletion;
using Microsoft.SemanticKernel;
using EtwPilot.ViewModel;
using System.Reflection;

namespace EtwPilot.InferenceRuntimes
{
    internal class LlamaCpp : InferenceRuntimeBase
    {
        private readonly string m_Grammars;

        public LlamaCpp(Kernel kernel, ChatHistory History) : base(kernel, History)
        {
            var grammars = new GrammarGenerator(kernel);
            m_Grammars = grammars.GenerateGrammars();
        }

        public override async Task GenerateAsync(string UserPrompt, CancellationToken Token, ProgressState Progress)
        {
            //
            // TODO
            //
            throw new NotImplementedException();
        }
    }

    //
    // Note: Modified code generated by Grok 3/25/25
    //
    internal class GrammarGenerator
    {
        private readonly Kernel m_Kernel;
        private Dictionary<Type, string> _typeRules = new();
        private List<string> _customTypeDefinitions = new();
        private readonly Dictionary<string, string> _grammars = new();

        public GrammarGenerator(Kernel kernel)
        {
            m_Kernel = kernel;
        }

        public string GenerateGrammars()
        {
            var functions = m_Kernel.Plugins.GetFunctionsMetadata();
            var grammarLines = new List<string>
            {
                "root ::= \"{\" ws \"\\\"function\\\"\" ws \":\" ws \"\\\"\" function_name \"\\\"\" ws \",\" ws \"\\\"args\\\"\" ws \":\" ws \"{\" ws arg_pairs ws \"}\" ws \"}\"",
                "function_name ::= " + string.Join(" | ", functions.Select(f => $"\"{f.Name}\"").Distinct()),
                "arg_pairs ::= " + string.Join(" | ", functions.Select(f => $"{f.Name}_args"))
            };

            foreach (var func in functions)
            {
                var args = new List<string>();
                foreach (var param in func.Parameters)
                {
                    string typeRule = GetTypeRule(param.ParameterType);
                    string paramRule = $"\"{param.Name}\" ws \":\" ws {typeRule}";
                    if (!param.IsRequired)
                        paramRule = $"({paramRule})?"; // Optional params
                    args.Add(paramRule);
                }
                grammarLines.Add($"{func.Name}_args ::= {string.Join(" ws ", args)}");
            }

            // Add custom type definitions
            grammarLines.AddRange(_customTypeDefinitions);

            // Basic type definitions
            grammarLines.AddRange(new[]
            {
                "string ::= \"\\\"\" [a-zA-Z0-9 ]+ \"\\\"\"",
                "number ::= \"-\"? [0-9]+ (\".\" [0-9]+)?",
                "ws ::= [ \\t\\n]*"
            });

            return string.Join("\n", grammarLines);
        }

        private string GetTypeRule(Type type)
        {
            // Check if already defined
            if (_typeRules.TryGetValue(type, out string rule))
                return rule;

            // Primitive types
            if (type == typeof(string))
                return "string";
            if (type == typeof(int) || type == typeof(float) || type == typeof(double))
                return "number";

            // Enum types
            if (type.IsEnum)
            {
                string enumName = type.Name.ToLower();
                string enumRule = string.Join(" | ", Enum.GetNames(type).Select(n => $"\"{n}\""));
                _customTypeDefinitions.Add($"{enumName} ::= {enumRule}");
                _typeRules[type] = enumName;
                return enumName;
            }

            // Generic List<T>
            if (type.IsGenericType && type.GetGenericTypeDefinition() == typeof(List<>))
            {
                Type itemType = type.GetGenericArguments()[0];
                string itemRule = GetTypeRule(itemType);
                string listName = $"{itemType.Name.ToLower()}_list";
                _customTypeDefinitions.Add($"{listName} ::= \"[\" ws ({itemRule} (\",\" ws {itemRule})*)? ws \"]\"");
                _typeRules[type] = listName;
                return listName;
            }

            // Custom class/struct
            if (type.IsClass || type.IsValueType && !type.IsPrimitive)
            {
                string typeName = type.Name.ToLower();
                var properties = type.GetProperties(BindingFlags.Public | BindingFlags.Instance);
                var propRules = properties.Select(p =>
                    $"\"{p.Name}\" ws \":\" ws {GetTypeRule(p.PropertyType)}"
                );
                _customTypeDefinitions.Add($"{typeName} ::= \"{{\" ws {string.Join(" ws \",\" ws ", propRules)} ws \"}}\"");
                _typeRules[type] = typeName;
                return typeName;
            }

            throw new NotSupportedException($"Type {type.Name} not supported in grammar.");
        }
    }
}
