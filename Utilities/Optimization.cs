/* 
Licensed to the Apache Software Foundation (ASF) under one
or more contributor license agreements.  See the NOTICE file
distributed with this work for additional information
regarding copyright ownership.  The ASF licenses this file
to you under the Apache License, Version 2.0 (the
"License"); you may not use this file except in compliance
with the License.  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing,
software distributed under the License is distributed on an
"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, either express or implied.  See the License for the
specific language governing permissions and limitations
under the License.
*/
using etwlib;
using System.Text.Json;

public class EtwManifestCompressor
{
    /// <summary>
    /// Generated by Grok AI.
    /// </summary>
    /// <param name="manifest"></param>
    /// <returns></returns>
    public static string Compress(ParsedEtwManifest manifest)
    {
        var json = new
        {
            Provider = new
            {
                Id = manifest.Provider.Id,
                Name = manifest.Provider.Name,
                Source = manifest.Provider.Source,
                HasManifest = manifest.Provider.HasManifest ? 1 : 0
            },
            Events = (manifest.Events ?? new List<ParsedEtwManifestEvent>()).Select(evt => new
            {
                Id = evt.Id,
                Version = evt.Version,
                Opcode = evt.Opcode ?? "",
                Channel = evt.Channel ?? "",
                Level = evt.Level ?? "",
                Keywords = evt.Keywords ?? "",
                Task = evt.Task,
                Template = evt.Template ?? ""
            }).ToArray(),
            Channels = (manifest.Channels ?? new List<ParsedEtwManifestField>()).Select(c => new
            {
                Name = c.Name,
                Description = c.Description,
                Value = c.Value
            }).ToArray(),
            Keywords = (manifest.Keywords ?? new List<ParsedEtwManifestField>()).Select(k => new
            {
                Name = k.Name,
                Description = k.Description,
                Value = k.Value
            }).ToArray(),
            Tasks = CompressTasks(manifest.Tasks ?? new Dictionary<ParsedEtwManifestField, List<ParsedEtwManifestField>>()),
            GlobalOpcodes = (manifest.GlobalOpcodes ?? new List<ParsedEtwManifestField>()).Select(o => new
            {
                Name = o.Name,
                Description = o.Description,
                Value = o.Value
            }).ToArray(),
            Templates = CompressTemplates(manifest.Templates ?? new Dictionary<string, List<ParsedEtwTemplateItem>>()),
            StringTable = (manifest.StringTable ?? new List<string>()).ToArray()
        };

        return JsonSerializer.Serialize(json, new JsonSerializerOptions { WriteIndented = false });
    }

    private static object[] CompressTasks(Dictionary<ParsedEtwManifestField, List<ParsedEtwManifestField>> tasks)
    {
        var taskGroups = tasks
            .GroupBy(t => (Name: t.Key.Name, Description: t.Key.Description, Opcodes: t.Value.OrderBy(o => o.Name).Select(o => (o.Name, o.Description, o.Value)).ToList()))
            .Select(g => new
            {
                Name = g.Key.Name,
                Description = g.Key.Description,
                TaskValues = GetTaskValueRanges(g.Select(t => t.Key.Value).OrderBy(v => v).ToList()),
                Opcodes = g.Key.Opcodes.Select(o => new { Name = o.Name, Description = o.Description, Value = o.Value }).ToArray()
            }).ToArray();

        return taskGroups.Select(g => new
        {
            Name = g.Name,
            Description = g.Description,
            TaskValues = g.TaskValues.Select(r => r.Start == r.End ? r.Start.ToString() : $"{r.Start}-{r.End}").ToArray(),
            Opcodes = g.Opcodes
        }).ToArray<object>();
    }

    private static object[] CompressTemplates(Dictionary<string, List<ParsedEtwTemplateItem>> templates)
    {
        var sortedTemplates = templates.OrderBy(t => t.Key).ToList();
        var templateGroups = new List<(string KeyStart, string KeyEnd, List<ParsedEtwTemplateItem> Items)>();
        int i = 0;
        while (i < sortedTemplates.Count)
        {
            var current = sortedTemplates[i];
            string keyStart = current.Key;
            string keyEnd = current.Key;
            var items = current.Value;
            int j = i + 1;
            while (j < sortedTemplates.Count && AreTemplateItemsEqual(items, sortedTemplates[j].Value))
            {
                keyEnd = sortedTemplates[j].Key;
                j++;
            }
            templateGroups.Add((keyStart, keyEnd, items));
            i = j;
        }

        return templateGroups.Select(g => new
        {
            TemplateKey = g.KeyStart == g.KeyEnd ? g.KeyStart : $"{g.KeyStart}-{g.KeyEnd}",
            Items = g.Items.Select(item => new
            {
                Name = item.Name,
                InType = item.InType.ToString(),
                OutType = item.OutType.ToString(),
                Length = item.Length,
                Value = item.Value,
                Index = item.Index,
                Backreference = item.FieldBackreference != null ? new
                {
                    FieldName = item.FieldBackreference.FieldName ?? "",
                    FieldIndex = item.FieldBackreference.FieldIndex,
                    IsCountedField = item.FieldBackreference.IsCountedField ? 1 : 0
                } : null
            }).ToArray()
        }).ToArray<object>();
    }

    private static List<(ulong Start, ulong End)> GetTaskValueRanges(List<ulong> values)
    {
        var ranges = new List<(ulong Start, ulong End)>();
        if (!values.Any()) return ranges;

        values = values.OrderBy(v => v).ToList();
        ulong start = values[0];
        ulong prev = start;

        for (int i = 1; i < values.Count; i++)
        {
            if (values[i] != prev + 1)
            {
                ranges.Add((start, prev));
                start = values[i];
            }
            prev = values[i];
        }
        ranges.Add((start, prev));

        return ranges;
    }

    private static bool AreTemplateItemsEqual(List<ParsedEtwTemplateItem> items1, List<ParsedEtwTemplateItem> items2)
    {
        if (items1.Count != items2.Count) return false;
        for (int i = 0; i < items1.Count; i++)
        {
            var item1 = items1[i];
            var item2 = items2[i];
            if (item1.Name != item2.Name || item1.InType != item2.InType || item1.OutType != item2.OutType ||
                item1.Length != item2.Length || item1.Value != item2.Value || item1.Index != item2.Index ||
                !AreBackreferencesEqual(item1.FieldBackreference, item2.FieldBackreference))
            {
                return false;
            }
        }
        return true;
    }

    private static bool AreBackreferencesEqual(ParsedEtwTemplateItem.Backreference b1, ParsedEtwTemplateItem.Backreference b2)
    {
        if (b1 == null && b2 == null) return true;
        if (b1 == null || b2 == null) return false;
        return b1.FieldName == b2.FieldName && b1.FieldIndex == b2.FieldIndex && b1.IsCountedField == b2.IsCountedField;
    }


    public static string GetSystemPromptHint()
    {
        return @"The encoding is a JSON object with the following structure:
- Provider: { Id, Name, Source, HasManifest (0 or 1) }
- Events: Array of { Id, Version, Opcode, Channel, Level, Keywords, Task, Template }
- Channels: Array of { Name, Description, Value }
- Keywords: Array of { Name, Description, Value }
- Tasks: Array of { Name, Description, TaskValues (array of single values or ranges 'start-end'), Opcodes (array of { Name, Description, Value }) }. For ranges, apply the same opcodes to all TaskValues in the range
- GlobalOpcodes: Array of { Name, Description, Value }
- Templates: Array of { TemplateKey (single key or range 'keyStart-keyEnd'), Items (array of { Name, InType, OutType, Length, Value, Index, Backreference: { FieldName, FieldIndex, IsCountedField (0 or 1) } or null }) }. For ranges, apply the same items to all keys in the range
- StringTable: Array of strings";
    }
}